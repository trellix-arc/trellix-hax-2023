94,95c94,95
< static char * encrypt_var(char *varname, char *ctext, int ctext_len, char *ptext, int *ptext_len,char *key, int keylen);
< static char * decrypt_var(char *varname, char *ptext, int ptext_len, char *ctext, int *ctext_len,char *key, int keylen);
---
> // static char * encrypt_var(char *varname, char *ctext, int ctext_len, char *ptext, int *ptext_len,char *key, int keylen); NOTE
> // static char * decrypt_var(char *varname, char *ptext, int ptext_len, char *ctext, int *ctext_len,char *key, int keylen); NOTE
250a251
> #define sys_reboot() kill(1, SIGTERM) // NOTE
275,279c276,280
< inline void sys_reboot(void)
< {
< 	eval("wl", "reboot");
< 	kill(1, SIGTERM);
< }
---
> // inline void sys_reboot(void) NOTE
> // {
> // 	eval("wl", "reboot");
> // 	kill(1, SIGTERM);
> // }
2704,2705c2705,2706
< static int wps_gen_ssid(char *ssid, int ssid_len);
< static int wps_gen_key(char *key, int key_len);
---
> // static int wps_gen_ssid(char *ssid, int ssid_len); NOTE
> // static int wps_gen_key(char *key, int key_len); NOTE
3355c3356
< 			wps_gen_key(random_psk, sizeof(random_psk));
---
> 			strcpy(random_psk, "wps_gen_key REMOVED"); // wps_gen_key(random_psk, sizeof(random_psk)); NOTE
6073,6079c6074,6138
< /* generate a printable key string */
< static int
< wps_gen_key(char *key, int key_len)
< {
< 	unsigned short key_length;
< 	unsigned char random_key[64] = {0};
< 	int i = 0;
---
> // /* generate a printable key string */  NOTE
> // static int
> // wps_gen_key(char *key, int key_len)
> // {
> // 	unsigned short key_length;
> // 	unsigned char random_key[64] = {0};
> // 	int i = 0;
> 
> // 	if (key == NULL || key_len == 0)
> // 		return -1;
> 
> // 	/* key_length < 16 */
> // 	RAND_bytes((unsigned char *)&key_length, sizeof(key_length));
> // 	key_length = (unsigned short)((((long)key_length + 56791)*13579)%8) + 8;
> 
> // 	while (i < key_length) {
> // 		RAND_bytes(&random_key[i], 1);
> // 		if ((islower(random_key[i]) || isdigit(random_key[i])) &&
> // 			(random_key[i] < 0x7f)) {
> // 			i++;
> // 		}
> // 	}
> // 	memcpy(key, random_key, key_len);
> // 	return 0;
> // }
> 
> // static int NOTE
> // wps_gen_ssid(char *ssid, int ssid_len)
> // {
> // 	int i;
> // 	char mac[18] = {0};
> // 	unsigned short ssid_length;
> // 	unsigned char random_ssid[33] = {0};
> // 	char prefix[] = "wlXXXXXXXXXX_";
> // 	char vif[64];
> // 	char *value;
> 
> // 	if (ssid == NULL || ssid_len == 0)
> // 		return -1;
> 
> // 	if (!make_wl_prefix(prefix, sizeof(prefix), 1, NULL)) {
> // 		return -1;
> // 	}
> // 	snprintf(vif, sizeof(vif), "%shwaddr", prefix);
> // 	value  = nvram_get(vif);
> // 	strncpy(mac, value, sizeof(mac));
> 
> // 	RAND_bytes((unsigned char *)&ssid_length, sizeof(ssid_length));
> // 	ssid_length = (unsigned short)((((long)ssid_length + 56791)*13579)%8) + 1;
> 
> // 	RAND_bytes((unsigned char *)random_ssid, ssid_length);
> 
> // 	for (i = 0; i < ssid_length; i++) {
> // 		if ((random_ssid[i] < 48) || (random_ssid[i] > 57))
> // 			random_ssid[i] = random_ssid[i]%9 + 48;
> // 	}
> 
> // 	random_ssid[ssid_length++] = tolower(mac[6]);
> // 	random_ssid[ssid_length++] = tolower(mac[7]);
> // 	random_ssid[ssid_length++] = tolower(mac[9]);
> // 	random_ssid[ssid_length++] = tolower(mac[10]);
> // 	random_ssid[ssid_length++] = tolower(mac[12]);
> // 	random_ssid[ssid_length++] = tolower(mac[13]);
> // 	random_ssid[ssid_length++] = tolower(mac[15]);
> // 	random_ssid[ssid_length++] = tolower(mac[16]);
6081,6082c6140,6141
< 	if (key == NULL || key_len == 0)
< 		return -1;
---
> // 	memset(ssid, 0, ssid_len);
> // 	sprintf(ssid, "Broadcom_");
6084,6086c6143
< 	/* key_length < 16 */
< 	RAND_bytes((unsigned char *)&key_length, sizeof(key_length));
< 	key_length = (unsigned short)((((long)key_length + 56791)*13579)%8) + 8;
---
> // 	strncat(ssid, (char *)random_ssid, 33 - strlen(ssid) - 1);
6088,6145c6145,6146
< 	while (i < key_length) {
< 		RAND_bytes(&random_key[i], 1);
< 		if ((islower(random_key[i]) || isdigit(random_key[i])) &&
< 			(random_key[i] < 0x7f)) {
< 			i++;
< 		}
< 	}
< 	memcpy(key, random_key, key_len);
< 	return 0;
< }
< 
< static int
< wps_gen_ssid(char *ssid, int ssid_len)
< {
< 	int i;
< 	char mac[18] = {0};
< 	unsigned short ssid_length;
< 	unsigned char random_ssid[33] = {0};
< 	char prefix[] = "wlXXXXXXXXXX_";
< 	char vif[64];
< 	char *value;
< 
< 	if (ssid == NULL || ssid_len == 0)
< 		return -1;
< 
< 	if (!make_wl_prefix(prefix, sizeof(prefix), 1, NULL)) {
< 		return -1;
< 	}
< 	snprintf(vif, sizeof(vif), "%shwaddr", prefix);
< 	value  = nvram_get(vif);
< 	strncpy(mac, value, sizeof(mac));
< 
< 	RAND_bytes((unsigned char *)&ssid_length, sizeof(ssid_length));
< 	ssid_length = (unsigned short)((((long)ssid_length + 56791)*13579)%8) + 1;
< 
< 	RAND_bytes((unsigned char *)random_ssid, ssid_length);
< 
< 	for (i = 0; i < ssid_length; i++) {
< 		if ((random_ssid[i] < 48) || (random_ssid[i] > 57))
< 			random_ssid[i] = random_ssid[i]%9 + 48;
< 	}
< 
< 	random_ssid[ssid_length++] = tolower(mac[6]);
< 	random_ssid[ssid_length++] = tolower(mac[7]);
< 	random_ssid[ssid_length++] = tolower(mac[9]);
< 	random_ssid[ssid_length++] = tolower(mac[10]);
< 	random_ssid[ssid_length++] = tolower(mac[12]);
< 	random_ssid[ssid_length++] = tolower(mac[13]);
< 	random_ssid[ssid_length++] = tolower(mac[15]);
< 	random_ssid[ssid_length++] = tolower(mac[16]);
< 
< 	memset(ssid, 0, ssid_len);
< 	sprintf(ssid, "Broadcom_");
< 
< 	strncat(ssid, (char *)random_ssid, 33 - strlen(ssid) - 1);
< 
< 	return 0;
< }
---
> // 	return 0;
> // }
6223c6224
< 			wps_gen_ssid(random_ssid, sizeof(random_ssid));
---
> 			strcpy(random_ssid, "wps_gen_ssid REMOVED"); //wps_gen_ssid(random_ssid, sizeof(random_ssid)); NOTE
6231c6232
< 			wps_gen_key(random_psk, sizeof(random_psk));
---
> 			strcpy(random_psk, "wps_gen_key REMOVED"); // wps_gen_key(random_psk, sizeof(random_psk)); NOTE
14095,14394c14096,14457
< static void
< do_nvramul_post(char *url, FILE *stream, int len, char *boundary)
< {
< 	char buf[1024];
< 	int  index,cur_entry;
< 	char *ptr=NULL;
< 	char *name=NULL;
< 	char tmp[NVRAM_MAX_STRINGSIZE];
< 	char file_checksum[NVRAM_SHA1BUFSIZE],checksum[NVRAM_SHA1BUFSIZE];
< 	unsigned char key[NVRAM_SHA1BUFSIZE];
< 	int  checksum_linenum = NVRAM_CHECKSUM_LINENUM;
< 	char salt[NVRAM_SALTSIZE];
< 	int  numlines=0;
< 	int  entries,offset,slen;
< 	unsigned char passphrase[]=NVRAM_PASSPHRASE;
< 	char nvram_file_header[][NVRAM_MAX_STRINGSIZE/2] = NVRAM_FILEHEADER;
< 	upload_constraints constraint_vars [] = NVRAM_CONSTRAINT_VARS;
< 	struct pb {
< 			char header[NVRAM_HEADER_LINECOUNT(nvram_file_header)][NVRAM_MAX_STRINGSIZE];
< 			char buf[NVRAM_SPACE];
< 		 }*tmpbuf=NULL;
< #if !defined(WLTEST)
< 	struct variable *v = NULL;
< #endif /* !WLTEST */
< 
< #if __CONFIG_PROJECT_WUMC710__
< 	int is_text_file = 0, max_conf_file_size = 10240; // 10KB for maximum configuraion size
< #endif
< 
< 	assert(stream);
< 
< 	entries = NVRAM_HEADER_LINECOUNT(nvram_file_header);
< 	ret_code = EINVAL;
< 
< 	/* Look for our part */
< 	while (len > 0) {
< 		if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
< 			return;
< 
< 		/* Remove LF that fgets()drags in */
< 		len=remove_crlf(buf,len);
< 		/* look for start of attached file header */
< 
< 		if (*buf){
< 		  if (strstr(buf,NVRAM_BEGIN_WEBFILE)) break;
< 		}
< 
< 	}
< 
< 	if (!len) return;
< 
< 	/* loop thru the header lines until we get the blank line
< 	   that signifies the start of file contents */
< 	while (len > 0){
< 	 	if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
< 			return;
< 
< #if __CONFIG_PROJECT_WUMC710__
< 		// 2013/4/25, Dias Kuo, IE treats the content of configuration file as a text/plain, but Firefox, Chrome, Safari and Opera treat the content as an application/octet-stream
< 		// We have to process the content of application/octet-stream for the browser
< 		if ((is_text_file == 0) && ((len > max_conf_file_size) || (strncasecmp(buf, "Content-Type: text/plain", 24) && strncasecmp(buf, "Content-Type: application/octet-stream", 38)))){
< 			strncpy(posterr_msg,"Invalid NVRAM header<br>",ERR_MSG_SIZE);
< 			goto do_nvramul_post_cleanup0;
< 		}
< 		is_text_file = 1;
< #endif
< 		/* Remove LF that fgets()drags in */
< 		len=remove_crlf(buf,len);
< 
< 		/* look for the blank line */
< 		if (*buf == NVRAM_END_WEBFILE)  break;
< 	}
< 
< 	if (!len) return;
< 	/* Found start of upload file. Proceed with the upload */
< 	/* Look for start of upload data */
< 	if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
< 			return;
< 
< 	len = len - strlen(buf);
< 	/* Get the number of NVRAM variables */
< 	sprintf(tmp,"%s=%s",nvram_file_header[NVRAM_LINECOUNT_LINENUM],"%d");
< 
< 	if ( (sscanf(buf,tmp,&numlines) != 1) || !len ){
< 		strncpy(posterr_msg,"Invalid NVRAM header<br>",ERR_MSG_SIZE);
< #if __CONFIG_PROJECT_WUMC710__
< 		goto do_nvramul_post_cleanup0;
< #else
< 	 	return ;
< #endif
< 	}
< 
< 	if (numlines == 0) {
< 		strncpy(posterr_msg, "Invalid NVRAM header<br>", ERR_MSG_SIZE);
< #if __CONFIG_PROJECT_WUMC710__
< 	 	goto do_nvramul_post_cleanup0;
< #else
< 	 	return;
< #endif
< 	}
< 
< 	tmpbuf = (struct pb *) malloc( sizeof(struct pb));
< 	if (!tmpbuf){
< 		strncpy(posterr_msg,"Memory allocation error<br>",ERR_MSG_SIZE);
< #if __CONFIG_PROJECT_WUMC710__
< 	 	goto do_nvramul_post_cleanup0;
< #else
< 	 	return;
< #endif
< 	}
< 
< 	memset(tmpbuf,0,sizeof(struct pb));
< 
< 	/* Copy over the first line of the file. Needed for
< 	   proper checksum calculations */
< 
< 	strcpy(tmpbuf->header[0],buf);
< 
< 	/* read in checksum */
< 	if (!fgets(tmpbuf->header[1], MIN(len + 1,NVRAM_MAX_STRINGSIZE), stream))
< 			goto do_nvramul_post_cleanup0;
< 
< 	len = len - strlen(tmpbuf->header[1]);
< 
< 	/* start reading in the rest of the NVRAM contents into memory buffer*/
< 	offset = 0;
< 	for (index = 2 ; (len > 0) &&  (index < numlines); index++){
< 		char filebuf[NVRAM_MAX_STRINGSIZE];
< 
< 	 	if (!fgets(filebuf, MIN(len + 1,NVRAM_MAX_STRINGSIZE), stream))
< 			goto do_nvramul_post_cleanup0;
< 
< 		offset = add_string(&tmpbuf->buf[offset],filebuf,offset,
< 						sizeof(((struct pb *)0)->buf));
< 		if (offset < 0){
< 			snprintf(posterr_msg,ERR_MSG_SIZE,
< 				"Error processing NVRAM variable:%s<br>",filebuf);
< 	 		goto do_nvramul_post_cleanup0;
< 		}
< 		len = len - strlen(filebuf);
< 
< 		/* don't remove the LFs since the we are using  multipart
< 		   MIME encoding that does not touch the contents of the
< 		   uploaded file. LFs are actually part of the NVRAM var lines.
< 		*/
< 	}
< 
< 	/*  Bail if the number of actual lines is less than that
< 	    in the header
< 	*/
< 
< 	if ( !len && (index < numlines) ){
< 		strncpy(posterr_msg,"NVRAM file incomplete<br>",ERR_MSG_SIZE);
< 	 	goto do_nvramul_post_cleanup0;
< 	}
< 
< 	/* Save and decode checksum from file */
< 	ptr = tmpbuf->header[checksum_linenum];
< 
< 	sprintf(tmp,"%s=",nvram_file_header[checksum_linenum]);
< 
< 	if ( !strstr(ptr,tmp) ) {
< 		snprintf(posterr_msg,ERR_MSG_SIZE,
< 			"No checksum present at line %d<br>",checksum_linenum+1);
< 		goto do_nvramul_post_cleanup0 ;
< 	}
< 	ptr = &ptr[strlen(tmp)];
< 
< 	if ( b64_decode(ptr,(unsigned char *)tmp,NVRAM_MAX_STRINGSIZE) != NVRAM_FILECHKSUM_SIZE){
< 		strncpy(posterr_msg,"Invalid checksum.<br>",ERR_MSG_SIZE);
< 		goto do_nvramul_post_cleanup0 ;
< 	};
< 
< 	memset(file_checksum,0,sizeof(file_checksum));
< 	memcpy(file_checksum,tmp,NVRAM_HASHSIZE);
< 
< 	/* Extract salt value from stored checksum*/
< 	memcpy(salt,&tmp[NVRAM_HASHSIZE],NVRAM_SALTSIZE);
< 
< 	/* Regenerate encryption key */
< 	memset(key,0,sizeof(key));
< 	fPRF(passphrase,strlen((char *)passphrase),NULL,0,
< 			(unsigned char*)salt,sizeof(salt),key,NVRAM_FILEKEYSIZE);
< 
< 	/* Plug in filler for checksum into read buffer*/
< 	memset(tmpbuf->header[checksum_linenum],0,NVRAM_MAX_STRINGSIZE);
< 	snprintf(tmpbuf->header[checksum_linenum],
< 			NVRAM_MAX_STRINGSIZE,"%s\n",NVRAM_CHECKSUM_FILLER);
< 
< 	/* Calculate checksum and compare with stored value*/
< 
< 	memset(checksum,0,sizeof(checksum));
< 	hmac_sha1((unsigned char*)tmpbuf,sizeof(struct pb) ,
< 	          key,NVRAM_FILEKEYSIZE,(unsigned char *)checksum);
< 
< 	if (memcmp(checksum,file_checksum,NVRAM_HASHSIZE)){
< 		memcpy(posterr_msg,"File checksum error<br>",ERR_MSG_SIZE);
< 		goto do_nvramul_post_cleanup0;
< 	}
< 
< 	/* Check constraints on the data */
< 
< 	cur_entry = NVRAM_HEADER_LINECOUNT(nvram_file_header);
< 	slen=0;
< 	name = tmpbuf->buf;
< 	for (index = 0  ; *constraint_vars[index].name && *name; index++,cur_entry++,name += slen + 1) {
< 		char *var=NULL,*ptr=NULL;
< 		int comparesize ;
< 
< 		slen = strlen(name);
< 
< 		if (cur_entry > numlines){
< 			memcpy(posterr_msg,
< 				"Constraints mismatch between file and running image<br>",
< 										ERR_MSG_SIZE);
< 			goto do_nvramul_post_cleanup0;
< 		}
< 
< 
< 		var = constraint_vars[index].get(constraint_vars[index].name);
< 
< 		if (!var){
< 			snprintf(posterr_msg,ERR_MSG_SIZE,
< 				"NVRAM variable:%s not found in running image<br>",
< 								constraint_vars[index].name);
< 			goto do_nvramul_post_cleanup0;
< 		}
< 
< 		if (!strstr(name,constraint_vars[index].name)){
< 			snprintf(posterr_msg,ERR_MSG_SIZE,
< 				"NVRAM variable:%s not found in uploaded file<br>",
< 								constraint_vars[index].name);
< 			goto do_nvramul_post_cleanup0;
< 		}
< 
< 		/*Move past separator*/
< 		ptr = &name[strlen(constraint_vars[index].name) + 1] ;
< 
< 		/* Ignore last character which is a \n */
< 		comparesize = strlen(ptr) -1;
< 
< 		/* If the primary match fails try for the secomdary matches */
< 		if (strncmp(ptr,var,comparesize)){
< 		int sec_fail=0;
< 
< 			/* If partial march is defined match altval pattern against
< 			   file and image values*/
< 			if (constraint_vars[index].flags & NVRAM_CONS_PARTIAL_MATCH){
< 				sec_fail=( !strstr(ptr,constraint_vars[index].altval) &&
< 							!strstr(var,constraint_vars[index].altval));
< 			}
< 			else if (constraint_vars[index].flags & NVRAM_CONS_ALT_MATCH){
< 				sec_fail=(strncmp(ptr,constraint_vars[index].altval,comparesize));
< 			}
< 			else sec_fail =1;
< 
< 		if (sec_fail){
< 			snprintf(posterr_msg,ERR_MSG_SIZE,
< 				"NVRAM constraint mismatch FILE:<b>%s=%s</b>  IMAGE:<b>%s=%s</b><br>",
< 					constraint_vars[index].name,ptr,constraint_vars[index].name,var);
< 			goto do_nvramul_post_cleanup0;
< 			}
< 		}
< 
< 	}
< 
< 	/* Process the NVRAM payload
< 	 *
< 	 * Remove the carriage returns at the end of the NVRAM variables
< 	 *
< 	*/
< 
< 	cur_entry = NVRAM_HEADER_LINECOUNT(nvram_file_header) + NVRAM_HEADER_LINECOUNT(constraint_vars);
< 
< 	slen=0;
< 	for (index = cur_entry ;(index < numlines) && *name; index++,name += slen + 1){
< 		int offset;
< 		char *ptr=NULL;
< 		char *varname=NULL;
< 		char *myptr=NULL;
< 
< 		offset = index * NVRAM_MAX_STRINGSIZE;
< 
< 		/* The length of the actual var must be saved here as the subsequent
< 		 * manipulation using strsep() changes the string buffer.
< 		 * This to ensure that the buffer (tmpbuf->buf) is correctly procesed
< 		 * This buffer separates the individual AVPs using a null character
< 		 */
< 
< 		slen =strlen(name);
< 		ptr = name;
< 
< 		/* Remove the CR at the end of the string */
< 		ptr[slen-1] = '\0';
< 
< 		/* Look for tag that indicates that the value is encrypted */
< 		if  (*ptr==NVRAM_ENCTAG){
< 			char buf[NVRAM_MAX_STRINGSIZE];
< 			int bufsize = sizeof(buf);
< 			char *varname=NULL;
---
> // static void NOTE
> // do_nvramul_post(char *url, FILE *stream, int len, char *boundary)
> // {
> // 	char buf[1024];
> // 	int  index,cur_entry;
> // 	char *ptr=NULL;
> // 	char *name=NULL;
> // 	char tmp[NVRAM_MAX_STRINGSIZE];
> // 	char file_checksum[NVRAM_SHA1BUFSIZE],checksum[NVRAM_SHA1BUFSIZE];
> // 	unsigned char key[NVRAM_SHA1BUFSIZE];
> // 	int  checksum_linenum = NVRAM_CHECKSUM_LINENUM;
> // 	char salt[NVRAM_SALTSIZE];
> // 	int  numlines=0;
> // 	int  entries,offset,slen;
> // 	unsigned char passphrase[]=NVRAM_PASSPHRASE;
> // 	char nvram_file_header[][NVRAM_MAX_STRINGSIZE/2] = NVRAM_FILEHEADER;
> // 	upload_constraints constraint_vars [] = NVRAM_CONSTRAINT_VARS;
> // 	struct pb {
> // 			char header[NVRAM_HEADER_LINECOUNT(nvram_file_header)][NVRAM_MAX_STRINGSIZE];
> // 			char buf[NVRAM_SPACE];
> // 		 }*tmpbuf=NULL;
> // #if !defined(WLTEST)
> // 	struct variable *v = NULL;
> // #endif /* !WLTEST */
> 
> // #if __CONFIG_PROJECT_WUMC710__
> // 	int is_text_file = 0, max_conf_file_size = 10240; // 10KB for maximum configuraion size
> // #endif
> 
> // 	assert(stream);
> 
> // 	entries = NVRAM_HEADER_LINECOUNT(nvram_file_header);
> // 	ret_code = EINVAL;
> 
> // 	/* Look for our part */
> // 	while (len > 0) {
> // 		if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
> // 			return;
> 
> // 		/* Remove LF that fgets()drags in */
> // 		len=remove_crlf(buf,len);
> // 		/* look for start of attached file header */
> 
> // 		if (*buf){
> // 		  if (strstr(buf,NVRAM_BEGIN_WEBFILE)) break;
> // 		}
> 
> // 	}
> 
> // 	if (!len) return;
> 
> // 	/* loop thru the header lines until we get the blank line
> // 	   that signifies the start of file contents */
> // 	while (len > 0){
> // 	 	if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
> // 			return;
> 
> // #if __CONFIG_PROJECT_WUMC710__
> // 		// 2013/4/25, Dias Kuo, IE treats the content of configuration file as a text/plain, but Firefox, Chrome, Safari and Opera treat the content as an application/octet-stream
> // 		// We have to process the content of application/octet-stream for the browser
> // 		if ((is_text_file == 0) && ((len > max_conf_file_size) || (strncasecmp(buf, "Content-Type: text/plain", 24) && strncasecmp(buf, "Content-Type: application/octet-stream", 38)))){
> // 			strncpy(posterr_msg,"Invalid NVRAM header<br>",ERR_MSG_SIZE);
> // 			goto do_nvramul_post_cleanup0;
> // 		}
> // 		is_text_file = 1;
> // #endif
> // 		/* Remove LF that fgets()drags in */
> // 		len=remove_crlf(buf,len);
> 
> // 		/* look for the blank line */
> // 		if (*buf == NVRAM_END_WEBFILE)  break;
> // 	}
> 
> // 	if (!len) return;
> // 	/* Found start of upload file. Proceed with the upload */
> // 	/* Look for start of upload data */
> // 	if (!fgets(buf, MIN(len + 1, sizeof(buf)), stream))
> // 			return;
> 
> // 	len = len - strlen(buf);
> // 	/* Get the number of NVRAM variables */
> // 	sprintf(tmp,"%s=%s",nvram_file_header[NVRAM_LINECOUNT_LINENUM],"%d");
> 
> // 	if ( (sscanf(buf,tmp,&numlines) != 1) || !len ){
> // 		strncpy(posterr_msg,"Invalid NVRAM header<br>",ERR_MSG_SIZE);
> // #if __CONFIG_PROJECT_WUMC710__
> // 		goto do_nvramul_post_cleanup0;
> // #else
> // 	 	return ;
> // #endif
> // 	}
> 
> // 	if (numlines == 0) {
> // 		strncpy(posterr_msg, "Invalid NVRAM header<br>", ERR_MSG_SIZE);
> // #if __CONFIG_PROJECT_WUMC710__
> // 	 	goto do_nvramul_post_cleanup0;
> // #else
> // 	 	return;
> // #endif
> // 	}
> 
> // 	tmpbuf = (struct pb *) malloc( sizeof(struct pb));
> // 	if (!tmpbuf){
> // 		strncpy(posterr_msg,"Memory allocation error<br>",ERR_MSG_SIZE);
> // #if __CONFIG_PROJECT_WUMC710__
> // 	 	goto do_nvramul_post_cleanup0;
> // #else
> // 	 	return;
> // #endif
> // 	}
> 
> // 	memset(tmpbuf,0,sizeof(struct pb));
> 
> // 	/* Copy over the first line of the file. Needed for
> // 	   proper checksum calculations */
> 
> // 	strcpy(tmpbuf->header[0],buf);
> 
> // 	/* read in checksum */
> // 	if (!fgets(tmpbuf->header[1], MIN(len + 1,NVRAM_MAX_STRINGSIZE), stream))
> // 			goto do_nvramul_post_cleanup0;
> 
> // 	len = len - strlen(tmpbuf->header[1]);
> 
> // 	/* start reading in the rest of the NVRAM contents into memory buffer*/
> // 	offset = 0;
> // 	for (index = 2 ; (len > 0) &&  (index < numlines); index++){
> // 		char filebuf[NVRAM_MAX_STRINGSIZE];
> 
> // 	 	if (!fgets(filebuf, MIN(len + 1,NVRAM_MAX_STRINGSIZE), stream))
> // 			goto do_nvramul_post_cleanup0;
> 
> // 		offset = add_string(&tmpbuf->buf[offset],filebuf,offset,
> // 						sizeof(((struct pb *)0)->buf));
> // 		if (offset < 0){
> // 			snprintf(posterr_msg,ERR_MSG_SIZE,
> // 				"Error processing NVRAM variable:%s<br>",filebuf);
> // 	 		goto do_nvramul_post_cleanup0;
> // 		}
> // 		len = len - strlen(filebuf);
> 
> // 		/* don't remove the LFs since the we are using  multipart
> // 		   MIME encoding that does not touch the contents of the
> // 		   uploaded file. LFs are actually part of the NVRAM var lines.
> // 		*/
> // 	}
> 
> // 	/*  Bail if the number of actual lines is less than that
> // 	    in the header
> // 	*/
> 
> // 	if ( !len && (index < numlines) ){
> // 		strncpy(posterr_msg,"NVRAM file incomplete<br>",ERR_MSG_SIZE);
> // 	 	goto do_nvramul_post_cleanup0;
> // 	}
> 
> // 	/* Save and decode checksum from file */
> // 	ptr = tmpbuf->header[checksum_linenum];
> 
> // 	sprintf(tmp,"%s=",nvram_file_header[checksum_linenum]);
> 
> // 	if ( !strstr(ptr,tmp) ) {
> // 		snprintf(posterr_msg,ERR_MSG_SIZE,
> // 			"No checksum present at line %d<br>",checksum_linenum+1);
> // 		goto do_nvramul_post_cleanup0 ;
> // 	}
> // 	ptr = &ptr[strlen(tmp)];
> 
> // 	if ( b64_decode(ptr,(unsigned char *)tmp,NVRAM_MAX_STRINGSIZE) != NVRAM_FILECHKSUM_SIZE){
> // 		strncpy(posterr_msg,"Invalid checksum.<br>",ERR_MSG_SIZE);
> // 		goto do_nvramul_post_cleanup0 ;
> // 	};
> 
> // 	memset(file_checksum,0,sizeof(file_checksum));
> // 	memcpy(file_checksum,tmp,NVRAM_HASHSIZE);
> 
> // 	/* Extract salt value from stored checksum*/
> // 	memcpy(salt,&tmp[NVRAM_HASHSIZE],NVRAM_SALTSIZE);
> 
> // 	/* Regenerate encryption key */
> // 	memset(key,0,sizeof(key));
> // 	fPRF(passphrase,strlen((char *)passphrase),NULL,0,
> // 			(unsigned char*)salt,sizeof(salt),key,NVRAM_FILEKEYSIZE);
> 
> // 	/* Plug in filler for checksum into read buffer*/
> // 	memset(tmpbuf->header[checksum_linenum],0,NVRAM_MAX_STRINGSIZE);
> // 	snprintf(tmpbuf->header[checksum_linenum],
> // 			NVRAM_MAX_STRINGSIZE,"%s\n",NVRAM_CHECKSUM_FILLER);
> 
> // 	/* Calculate checksum and compare with stored value*/
> 
> // 	memset(checksum,0,sizeof(checksum));
> // 	hmac_sha1((unsigned char*)tmpbuf,sizeof(struct pb) ,
> // 	          key,NVRAM_FILEKEYSIZE,(unsigned char *)checksum);
> 
> // 	if (memcmp(checksum,file_checksum,NVRAM_HASHSIZE)){
> // 		memcpy(posterr_msg,"File checksum error<br>",ERR_MSG_SIZE);
> // 		goto do_nvramul_post_cleanup0;
> // 	}
> 
> // 	/* Check constraints on the data */
> 
> // 	cur_entry = NVRAM_HEADER_LINECOUNT(nvram_file_header);
> // 	slen=0;
> // 	name = tmpbuf->buf;
> // 	for (index = 0  ; *constraint_vars[index].name && *name; index++,cur_entry++,name += slen + 1) {
> // 		char *var=NULL,*ptr=NULL;
> // 		int comparesize ;
> 
> // 		slen = strlen(name);
> 
> // 		if (cur_entry > numlines){
> // 			memcpy(posterr_msg,
> // 				"Constraints mismatch between file and running image<br>",
> // 										ERR_MSG_SIZE);
> // 			goto do_nvramul_post_cleanup0;
> // 		}
> 
> 
> // 		var = constraint_vars[index].get(constraint_vars[index].name);
> 
> // 		if (!var){
> // 			snprintf(posterr_msg,ERR_MSG_SIZE,
> // 				"NVRAM variable:%s not found in running image<br>",
> // 								constraint_vars[index].name);
> // 			goto do_nvramul_post_cleanup0;
> // 		}
> 
> // 		if (!strstr(name,constraint_vars[index].name)){
> // 			snprintf(posterr_msg,ERR_MSG_SIZE,
> // 				"NVRAM variable:%s not found in uploaded file<br>",
> // 								constraint_vars[index].name);
> // 			goto do_nvramul_post_cleanup0;
> // 		}
> 
> // 		/*Move past separator*/
> // 		ptr = &name[strlen(constraint_vars[index].name) + 1] ;
> 
> // 		/* Ignore last character which is a \n */
> // 		comparesize = strlen(ptr) -1;
> 
> // 		/* If the primary match fails try for the secomdary matches */
> // 		if (strncmp(ptr,var,comparesize)){
> // 		int sec_fail=0;
> 
> // 			/* If partial march is defined match altval pattern against
> // 			   file and image values*/
> // 			if (constraint_vars[index].flags & NVRAM_CONS_PARTIAL_MATCH){
> // 				sec_fail=( !strstr(ptr,constraint_vars[index].altval) &&
> // 							!strstr(var,constraint_vars[index].altval));
> // 			}
> // 			else if (constraint_vars[index].flags & NVRAM_CONS_ALT_MATCH){
> // 				sec_fail=(strncmp(ptr,constraint_vars[index].altval,comparesize));
> // 			}
> // 			else sec_fail =1;
> 
> // 		if (sec_fail){
> // 			snprintf(posterr_msg,ERR_MSG_SIZE,
> // 				"NVRAM constraint mismatch FILE:<b>%s=%s</b>  IMAGE:<b>%s=%s</b><br>",
> // 					constraint_vars[index].name,ptr,constraint_vars[index].name,var);
> // 			goto do_nvramul_post_cleanup0;
> // 			}
> // 		}
> 
> // 	}
> 
> // 	/* Process the NVRAM payload
> // 	 *
> // 	 * Remove the carriage returns at the end of the NVRAM variables
> // 	 *
> // 	*/
> 
> // 	cur_entry = NVRAM_HEADER_LINECOUNT(nvram_file_header) + NVRAM_HEADER_LINECOUNT(constraint_vars);
> 
> // 	slen=0;
> // 	for (index = cur_entry ;(index < numlines) && *name; index++,name += slen + 1){
> // 		int offset;
> // 		char *ptr=NULL;
> // 		char *varname=NULL;
> // 		char *myptr=NULL;
> 
> // 		offset = index * NVRAM_MAX_STRINGSIZE;
> 
> // 		/* The length of the actual var must be saved here as the subsequent
> // 		 * manipulation using strsep() changes the string buffer.
> // 		 * This to ensure that the buffer (tmpbuf->buf) is correctly procesed
> // 		 * This buffer separates the individual AVPs using a null character
> // 		 */
> 
> // 		slen =strlen(name);
> // 		ptr = name;
> 
> // 		/* Remove the CR at the end of the string */
> // 		ptr[slen-1] = '\0';
> 
> // 		/* Look for tag that indicates that the value is encrypted */
> // 		if  (*ptr==NVRAM_ENCTAG){
> // 			char buf[NVRAM_MAX_STRINGSIZE];
> // 			int bufsize = sizeof(buf);
> // 			char *varname=NULL;
> 
> // 			varname=strsep(&ptr, "=");
> 
> // 			/* Increment pointer to move past tag */
> // 			varname++;
> 
> // 			if (!decrypt_var(varname,ptr,strlen(ptr),buf,&bufsize,(char *)key,NVRAM_FILEKEYSIZE)){
> // 				snprintf(posterr_msg,ERR_MSG_SIZE,
> // 					"Error decrypting value %s at line %d<br>",ptr,index);
> // 				goto do_nvramul_post_cleanup0;
> // 			}
> 
> // 		snprintf(name,NVRAM_MAX_STRINGSIZE,"%s=%s",varname,buf);
> 
> // 		}
> 
> // 		/*
> // 		   Write out NVRAM variables.
> // 		*/
> 
> // 		myptr = name;
> // 		varname=strsep(&myptr, "=");
> 
> // #if !defined(WLTEST)
> // 		v=get_var_handle(varname);
> 
> // 		/* Restore only those NVRAM vars in the validation table
> // 		   Ignore those with the obvious flag set
> // 		*/
> // 		if (!v)
> // 			continue;
> 
> // 		if (v->ezc_flags & NVRAM_IGNORE)
> // 			continue;
> // #endif /* !WLTEST */
> 
> // 		if (nvram_set(varname,myptr))
> // 			goto do_nvramul_post_cleanup0;
> 
> // 	}
> 
> // 	nvram_commit();
> 
> // 	/* We are done */
> // 	ret_code = 0;
> 
> // do_nvramul_post_cleanup0:
> // 	/* Clear up any outstanding stuff */
> // 	/* Slurp anything remaining in the request */
> 
> // #if __CONFIG_PROJECT_WUMC710__
> // 	if (is_text_file == 0) {
> // 		clean_binary_file_stream(NULL, stream, &len);
> // 	}
> 
> // 	if (is_text_file == 1) {
> // #endif
> // 		while (len--)
> // 			(void) fgetc(stream);
> // #if __CONFIG_PROJECT_WUMC710__
> // 	}
> // #endif
14396c14459
< 			varname=strsep(&ptr, "=");
---
> // 	if (tmpbuf) free(tmpbuf);
14398,14461c14461,14462
< 			/* Increment pointer to move past tag */
< 			varname++;
< 
< 			if (!decrypt_var(varname,ptr,strlen(ptr),buf,&bufsize,(char *)key,NVRAM_FILEKEYSIZE)){
< 				snprintf(posterr_msg,ERR_MSG_SIZE,
< 					"Error decrypting value %s at line %d<br>",ptr,index);
< 				goto do_nvramul_post_cleanup0;
< 			}
< 
< 		snprintf(name,NVRAM_MAX_STRINGSIZE,"%s=%s",varname,buf);
< 
< 		}
< 
< 		/*
< 		   Write out NVRAM variables.
< 		*/
< 
< 		myptr = name;
< 		varname=strsep(&myptr, "=");
< 
< #if !defined(WLTEST)
< 		v=get_var_handle(varname);
< 
< 		/* Restore only those NVRAM vars in the validation table
< 		   Ignore those with the obvious flag set
< 		*/
< 		if (!v)
< 			continue;
< 
< 		if (v->ezc_flags & NVRAM_IGNORE)
< 			continue;
< #endif /* !WLTEST */
< 
< 		if (nvram_set(varname,myptr))
< 			goto do_nvramul_post_cleanup0;
< 
< 	}
< 
< 	nvram_commit();
< 
< 	/* We are done */
< 	ret_code = 0;
< 
< do_nvramul_post_cleanup0:
< 	/* Clear up any outstanding stuff */
< 	/* Slurp anything remaining in the request */
< 
< #if __CONFIG_PROJECT_WUMC710__
< 	if (is_text_file == 0) {
< 		clean_binary_file_stream(NULL, stream, &len);
< 	}
< 
< 	if (is_text_file == 1) {
< #endif
< 		while (len--)
< 			(void) fgetc(stream);
< #if __CONFIG_PROJECT_WUMC710__
< 	}
< #endif
< 
< 	if (tmpbuf) free(tmpbuf);
< 
< 	return;
< }
---
> // 	return;
> // }
14531,14590c14532,14591
< static int
< save_nvram_var(char *name, char *var_val,char *buf, int buflen,char *key, int keylen)
< {
< 	char tmp[NVRAM_MAX_STRINGSIZE];
< 	int len=sizeof(tmp);
< 	int retval=0;
< 	struct variable *v = NULL;
< 
< 	assert(name);
< 	assert(buf);
< 	assert(key);
< 	assert(buflen);
< 	assert(keylen);
< 
< 
< 	/* If var_val is null, this forces the variable to be unset when the file is uploaded
< 	  If the variable is supposed to be encrypted but is null, skip it and do not
< 	  mark the string as encrypted.
< 
< 	  If var_val is null the variable does not exist. Skip and do not save in that case.
< 	*/
< 
< 	v = get_var_handle(name);
< 
< 	if (!v) {
< #if defined(WLTEST)
< 		retval= snprintf(buf,buflen,"%s=%s\n", (char_t *)name, (char_t *)var_val);
< 		return retval;
< #else
< 		return 0;
< #endif /* WLTEST */
< 	}
< 
< 	if (v->ezc_flags & NVRAM_IGNORE)
< 		return 0;
< 
< 	if (var_val) {
< 			if (strlen(var_val) > NVRAM_MAX_STRINGSIZE){
< 				cprintf("get_nvram_var():String too long Len=%d String=%s\n",	strlen(var_val) ,var_val);
< 				return -1;
< 			}
< 
< 			if ( (v->ezc_flags & NVRAM_ENCRYPT) && (*var_val) ){
< 				var_val = encrypt_var(name,var_val,strlen(var_val),tmp,&len,key,keylen);
< 
< 				if (!var_val){
< 					cprintf("get_nvram_var():Error encrypting %s\n",name);
< 					return -1;
< 				}
< 
< 				retval=snprintf(buf,buflen,"%c%s=%s\n",
< 						NVRAM_ENCTAG,
< 						(char_t *)name,
< 						(char_t *)var_val);
< 		    } else retval=snprintf(buf,buflen,"%s=%s\n",
< 						(char_t *)name,
< 						(char_t *)var_val);
< 	}
< 	return retval;
< }
---
> // static int NOTE
> // save_nvram_var(char *name, char *var_val,char *buf, int buflen,char *key, int keylen)
> // {
> // 	char tmp[NVRAM_MAX_STRINGSIZE];
> // 	int len=sizeof(tmp);
> // 	int retval=0;
> // 	struct variable *v = NULL;
> 
> // 	assert(name);
> // 	assert(buf);
> // 	assert(key);
> // 	assert(buflen);
> // 	assert(keylen);
> 
> 
> // 	/* If var_val is null, this forces the variable to be unset when the file is uploaded
> // 	  If the variable is supposed to be encrypted but is null, skip it and do not
> // 	  mark the string as encrypted.
> 
> // 	  If var_val is null the variable does not exist. Skip and do not save in that case.
> // 	*/
> 
> // 	v = get_var_handle(name);
> 
> // 	if (!v) {
> // #if defined(WLTEST)
> // 		retval= snprintf(buf,buflen,"%s=%s\n", (char_t *)name, (char_t *)var_val);
> // 		return retval;
> // #else
> // 		return 0;
> // #endif /* WLTEST */
> // 	}
> 
> // 	if (v->ezc_flags & NVRAM_IGNORE)
> // 		return 0;
> 
> // 	if (var_val) {
> // 			if (strlen(var_val) > NVRAM_MAX_STRINGSIZE){
> // 				cprintf("get_nvram_var():String too long Len=%d String=%s\n",	strlen(var_val) ,var_val);
> // 				return -1;
> // 			}
> 
> // 			if ( (v->ezc_flags & NVRAM_ENCRYPT) && (*var_val) ){
> // 				var_val = encrypt_var(name,var_val,strlen(var_val),tmp,&len,key,keylen);
> 
> // 				if (!var_val){
> // 					cprintf("get_nvram_var():Error encrypting %s\n",name);
> // 					return -1;
> // 				}
> 
> // 				retval=snprintf(buf,buflen,"%c%s=%s\n",
> // 						NVRAM_ENCTAG,
> // 						(char_t *)name,
> // 						(char_t *)var_val);
> // 		    } else retval=snprintf(buf,buflen,"%s=%s\n",
> // 						(char_t *)name,
> // 						(char_t *)var_val);
> // 	}
> // 	return retval;
> // }
14599,14623c14600,14763
< static void
< do_nvramdl_cgi(char *url, FILE *stream)
< {
< 	char checksum[NVRAM_SHA1BUFSIZE];
< 	unsigned char passphrase[]=NVRAM_PASSPHRASE;
< 	char salt[NVRAM_SALTSIZE];
< 	unsigned char key[NVRAM_SHA1BUFSIZE];
< 	int entries;
< 	char tmp[NVRAM_MAX_STRINGSIZE],tmp1[NVRAM_MAX_STRINGSIZE];
< 	char tmp_buf[NVRAM_MAX_STRINGSIZE];
< 	char *buf=NULL;
< 	char *var_val=NULL;
< 	char *var_name=NULL;
< 	char *name=NULL;
< 	char *ptr=NULL;
< 	int index;
< 	int retval;
< 	upload_constraints constraint_vars [] = NVRAM_CONSTRAINT_VARS;
< 	char nvram_file_header[][NVRAM_MAX_STRINGSIZE/2] = NVRAM_FILEHEADER;
< 	struct pb {
< 			char header[NVRAM_HEADER_LINECOUNT(nvram_file_header)][NVRAM_MAX_STRINGSIZE];
< 			char buf[NVRAM_SPACE];
< 		 } *post_buf=NULL;
< 
< 	int offset = 0;
---
> // static void NOTE
> // do_nvramdl_cgi(char *url, FILE *stream)
> // {
> // 	char checksum[NVRAM_SHA1BUFSIZE];
> // 	unsigned char passphrase[]=NVRAM_PASSPHRASE;
> // 	char salt[NVRAM_SALTSIZE];
> // 	unsigned char key[NVRAM_SHA1BUFSIZE];
> // 	int entries;
> // 	char tmp[NVRAM_MAX_STRINGSIZE],tmp1[NVRAM_MAX_STRINGSIZE];
> // 	char tmp_buf[NVRAM_MAX_STRINGSIZE];
> // 	char *buf=NULL;
> // 	char *var_val=NULL;
> // 	char *var_name=NULL;
> // 	char *name=NULL;
> // 	char *ptr=NULL;
> // 	int index;
> // 	int retval;
> // 	upload_constraints constraint_vars [] = NVRAM_CONSTRAINT_VARS;
> // 	char nvram_file_header[][NVRAM_MAX_STRINGSIZE/2] = NVRAM_FILEHEADER;
> // 	struct pb {
> // 			char header[NVRAM_HEADER_LINECOUNT(nvram_file_header)][NVRAM_MAX_STRINGSIZE];
> // 			char buf[NVRAM_SPACE];
> // 		 } *post_buf=NULL;
> 
> // 	int offset = 0;
> 
> // 	assert(stream);
> 
> // 	post_buf = (struct pb *)malloc(sizeof (struct pb));
> 
> // 	if (!post_buf) {
> // 		cprintf("do_nvramdl_cgi():Error allocating %d bytes for post_buf\n",
> // 						sizeof (struct pb));
> // 		goto do_nvramdl_cgi_error;
> // 	}
> 
> // 	buf = (char *)malloc(NVRAM_SPACE);
> 
> // 	if (!buf) {
> // 		cprintf("do_nvramdl_cgi():Error allocating %d bytes for buf\n",
> // 						NVRAM_SPACE);
> // 		goto do_nvramdl_cgi_error;
> // 	}
> 
> // 	memset (post_buf,0,sizeof(struct pb));
> // 	memset (buf,0,NVRAM_SPACE);
> 
> // 	assert(stream);
> 
> // 	entries = NVRAM_HEADER_LINECOUNT(nvram_file_header);
> // 	memset(tmp_buf,0,sizeof(tmp_buf));
> 
> // 	memset(salt,0,sizeof(salt));
> 
> // 	srand(time((time_t *)NULL));
> // 	for (index = 0 ; index < 30 ; index ++) rand();
> // 	index =rand();
> // 	memcpy(&salt[sizeof(index)],&index,sizeof(index));
> // 	for (index = 0 ; index < 30 ; index ++) rand();
> // 	index =rand();
> // 	memcpy(&salt,&index,sizeof(index));
> 
> // 	/*
> // 	   The first entry of the file is the number of variables
> // 	   The second entry is the offset to the start of the NVRAM variables
> // 	   The third entry is the SHA1 checksum
> // 	*/
> 
> // 	/* PopulateHeader info */
> // 	offset = 0;
> // 	for  (index =0 ;*constraint_vars[index].name;index++){
> // 		entries++;
> // 		var_val=constraint_vars[index].get(constraint_vars[index].name);
> // 		snprintf(tmp_buf,NVRAM_MAX_STRINGSIZE,"%s=%s\n",
> // 					constraint_vars[index].name,
> // 					(var_val) ? var_val : "unknown");
> // 		if (!offset) cprintf("Post_buf address = %p\n",&post_buf->buf[offset]);
> // 		offset = add_string(&post_buf->buf[offset],tmp_buf,offset,sizeof(struct pb));
> // 		if (offset < 0){
> // 			cprintf("httpd: Error Adding NVRAM header info.\n");
> // 			goto do_nvramdl_cgi_error;
> // 		}
> // 	};
> 
> // 	memset(key,0,sizeof(key));
> // 	fPRF(passphrase,strlen((char *)passphrase),NULL,0,
> // 			(unsigned char*)salt,sizeof(salt),key,NVRAM_FILEKEYSIZE);
> 
> // 	/* Plug in filler for checksum */
> // 	snprintf(post_buf->header[NVRAM_CHECKSUM_LINENUM],NVRAM_MAX_STRINGSIZE,"%s\n",NVRAM_CHECKSUM_FILLER);
> // 	/* Grab the NVRAM buffer */
> 
> // 	nvram_getall(buf, NVRAM_SPACE);
> 
> // 	for(name = buf; *name; name += strlen(name) + 1){
> // 		var_val =tmp;
> // 		strncpy(tmp,name,sizeof(tmp));
> // 		var_name=strsep(&var_val,"=");
> // 		retval = save_nvram_var(var_name,var_val,tmp_buf,
> // 					sizeof(tmp_buf),(char *)key,NVRAM_FILEKEYSIZE);
> 
> // 		if (retval <0){
> // 			cprintf("httpd: Error Adding NVRAM variable info.\n");
> // 			goto do_nvramdl_cgi_error;
> // 		};
> 
> // 		if  (retval > 0 ) {
> // 			entries++;
> // 			offset = add_string(&post_buf->buf[offset],tmp_buf,offset,sizeof(struct pb));
> // 			if (offset < 0){
> // 				cprintf("httpd: Error Adding NVRAM variable info.\n");
> // 				goto do_nvramdl_cgi_error;
> // 			}
> // 		};
> 
> // 		if (offset > NVRAM_SPACE) {
> // 			cprintf("httpd: NVRAM_SPACE of %d (%d) exceeded\n",NVRAM_SPACE,offset);
> // 			goto do_nvramdl_cgi_error;
> // 		};
> // 	}
> 
> 
> // 	/* Add the header info */
> // 	snprintf(post_buf->header[NVRAM_LINECOUNT_LINENUM],NVRAM_MAX_STRINGSIZE,"%s=%d\n",
> // 					nvram_file_header[NVRAM_LINECOUNT_LINENUM],entries);
> 
> // 	/*Generate the hash */
> 
> // 	memset(checksum,0,sizeof(checksum));
> // 	hmac_sha1((unsigned char*)post_buf,sizeof(struct pb),key,NVRAM_FILEKEYSIZE,
> // 	          (unsigned char*)checksum);
> 
> // 	memcpy(tmp,checksum,NVRAM_HASHSIZE);
> // 	memcpy(&tmp[NVRAM_HASHSIZE],salt,NVRAM_SALTSIZE);
> 
> // 	ptr = b64_encode((unsigned char *)tmp, NVRAM_FILECHKSUM_SIZE,
> // 	                 (unsigned char *)buf, NVRAM_SPACE );
> 
> // 	if (!ptr){
> // 		cprintf("do_nvramdl_cgi():Error performing base-64 encode of NVRAM checksum.\n");
> // 		goto do_nvramdl_cgi_error;
> // 	}
> 
> // 	strncpy(tmp1,ptr,NVRAM_MAX_STRINGSIZE);
> 
> // 	snprintf(post_buf->header[NVRAM_CHECKSUM_LINENUM],NVRAM_MAX_STRINGSIZE,"%s=%s\n",
> // 					nvram_file_header[NVRAM_CHECKSUM_LINENUM],tmp1);
> // 	/* Write out header */
> // 	for (index =0; index < NVRAM_HEADER_LINECOUNT(nvram_file_header) ; index ++)
> // 		websWrite(stream, "%s", post_buf->header[index]);
> 
> // 	/* Write out rest of file */
> 
> // 	for(name = post_buf->buf; *name; name += strlen(name) + 1){
> // 		/*cprintf("Val->%s\n",name);*/
> // 		websWrite(stream, "%s", name);
> // 		};
> 
> // do_nvramdl_cgi_error:
> 
> // 	if (post_buf)
> // 		free(post_buf);
> // 	if (buf)
> // 		free(buf);
14625,14742c14765
< 	assert(stream);
< 
< 	post_buf = (struct pb *)malloc(sizeof (struct pb));
< 
< 	if (!post_buf) {
< 		cprintf("do_nvramdl_cgi():Error allocating %d bytes for post_buf\n",
< 						sizeof (struct pb));
< 		goto do_nvramdl_cgi_error;
< 	}
< 
< 	buf = (char *)malloc(NVRAM_SPACE);
< 
< 	if (!buf) {
< 		cprintf("do_nvramdl_cgi():Error allocating %d bytes for buf\n",
< 						NVRAM_SPACE);
< 		goto do_nvramdl_cgi_error;
< 	}
< 
< 	memset (post_buf,0,sizeof(struct pb));
< 	memset (buf,0,NVRAM_SPACE);
< 
< 	assert(stream);
< 
< 	entries = NVRAM_HEADER_LINECOUNT(nvram_file_header);
< 	memset(tmp_buf,0,sizeof(tmp_buf));
< 
< 	memset(salt,0,sizeof(salt));
< 
< 	srand(time((time_t *)NULL));
< 	for (index = 0 ; index < 30 ; index ++) rand();
< 	index =rand();
< 	memcpy(&salt[sizeof(index)],&index,sizeof(index));
< 	for (index = 0 ; index < 30 ; index ++) rand();
< 	index =rand();
< 	memcpy(&salt,&index,sizeof(index));
< 
< 	/*
< 	   The first entry of the file is the number of variables
< 	   The second entry is the offset to the start of the NVRAM variables
< 	   The third entry is the SHA1 checksum
< 	*/
< 
< 	/* PopulateHeader info */
< 	offset = 0;
< 	for  (index =0 ;*constraint_vars[index].name;index++){
< 		entries++;
< 		var_val=constraint_vars[index].get(constraint_vars[index].name);
< 		snprintf(tmp_buf,NVRAM_MAX_STRINGSIZE,"%s=%s\n",
< 					constraint_vars[index].name,
< 					(var_val) ? var_val : "unknown");
< 		if (!offset) cprintf("Post_buf address = %p\n",&post_buf->buf[offset]);
< 		offset = add_string(&post_buf->buf[offset],tmp_buf,offset,sizeof(struct pb));
< 		if (offset < 0){
< 			cprintf("httpd: Error Adding NVRAM header info.\n");
< 			goto do_nvramdl_cgi_error;
< 		}
< 	};
< 
< 	memset(key,0,sizeof(key));
< 	fPRF(passphrase,strlen((char *)passphrase),NULL,0,
< 			(unsigned char*)salt,sizeof(salt),key,NVRAM_FILEKEYSIZE);
< 
< 	/* Plug in filler for checksum */
< 	snprintf(post_buf->header[NVRAM_CHECKSUM_LINENUM],NVRAM_MAX_STRINGSIZE,"%s\n",NVRAM_CHECKSUM_FILLER);
< 	/* Grab the NVRAM buffer */
< 
< 	nvram_getall(buf, NVRAM_SPACE);
< 
< 	for(name = buf; *name; name += strlen(name) + 1){
< 		var_val =tmp;
< 		strncpy(tmp,name,sizeof(tmp));
< 		var_name=strsep(&var_val,"=");
< 		retval = save_nvram_var(var_name,var_val,tmp_buf,
< 					sizeof(tmp_buf),(char *)key,NVRAM_FILEKEYSIZE);
< 
< 		if (retval <0){
< 			cprintf("httpd: Error Adding NVRAM variable info.\n");
< 			goto do_nvramdl_cgi_error;
< 		};
< 
< 		if  (retval > 0 ) {
< 			entries++;
< 			offset = add_string(&post_buf->buf[offset],tmp_buf,offset,sizeof(struct pb));
< 			if (offset < 0){
< 				cprintf("httpd: Error Adding NVRAM variable info.\n");
< 				goto do_nvramdl_cgi_error;
< 			}
< 		};
< 
< 		if (offset > NVRAM_SPACE) {
< 			cprintf("httpd: NVRAM_SPACE of %d (%d) exceeded\n",NVRAM_SPACE,offset);
< 			goto do_nvramdl_cgi_error;
< 		};
< 	}
< 
< 
< 	/* Add the header info */
< 	snprintf(post_buf->header[NVRAM_LINECOUNT_LINENUM],NVRAM_MAX_STRINGSIZE,"%s=%d\n",
< 					nvram_file_header[NVRAM_LINECOUNT_LINENUM],entries);
< 
< 	/*Generate the hash */
< 
< 	memset(checksum,0,sizeof(checksum));
< 	hmac_sha1((unsigned char*)post_buf,sizeof(struct pb),key,NVRAM_FILEKEYSIZE,
< 	          (unsigned char*)checksum);
< 
< 	memcpy(tmp,checksum,NVRAM_HASHSIZE);
< 	memcpy(&tmp[NVRAM_HASHSIZE],salt,NVRAM_SALTSIZE);
< 
< 	ptr = b64_encode((unsigned char *)tmp, NVRAM_FILECHKSUM_SIZE,
< 	                 (unsigned char *)buf, NVRAM_SPACE );
< 
< 	if (!ptr){
< 		cprintf("do_nvramdl_cgi():Error performing base-64 encode of NVRAM checksum.\n");
< 		goto do_nvramdl_cgi_error;
< 	}
< 
< 	strncpy(tmp1,ptr,NVRAM_MAX_STRINGSIZE);
---
> // 	websDone(stream, 200);
14744,14767c14767,14768
< 	snprintf(post_buf->header[NVRAM_CHECKSUM_LINENUM],NVRAM_MAX_STRINGSIZE,"%s=%s\n",
< 					nvram_file_header[NVRAM_CHECKSUM_LINENUM],tmp1);
< 	/* Write out header */
< 	for (index =0; index < NVRAM_HEADER_LINECOUNT(nvram_file_header) ; index ++)
< 		websWrite(stream, "%s", post_buf->header[index]);
< 
< 	/* Write out rest of file */
< 
< 	for(name = post_buf->buf; *name; name += strlen(name) + 1){
< 		/*cprintf("Val->%s\n",name);*/
< 		websWrite(stream, "%s", name);
< 		};
< 
< do_nvramdl_cgi_error:
< 
< 	if (post_buf)
< 		free(post_buf);
< 	if (buf)
< 		free(buf);
< 
< 	websDone(stream, 200);
< 
< 	return;
< }
---
> // 	return;
> // }
15706,15711c15707,15712
< static char*
< decrypt_var(char *varname,char *ctext, int ctext_len, char *ptext, int *ptext_len,char *key, int keylen)
< {
< 	unsigned char tmp[NVRAM_MAX_STRINGSIZE];
< 	int len;
< 	char *end=NULL;
---
> // static char* NOTE
> // decrypt_var(char *varname,char *ctext, int ctext_len, char *ptext, int *ptext_len,char *key, int keylen)
> // {
> // 	unsigned char tmp[NVRAM_MAX_STRINGSIZE];
> // 	int len;
> // 	char *end=NULL;
15713,15717c15714,15718
< 	assert(ptext);
< 	assert(ctext);
< 	assert(ptext_len);
< 	assert(key);
< 	if (keylen < 1 ) return NULL;
---
> // 	assert(ptext);
> // 	assert(ctext);
> // 	assert(ptext_len);
> // 	assert(key);
> // 	if (keylen < 1 ) return NULL;
15719,15722c15720,15723
< 	if (ctext_len > NVRAM_MAX_STRINGSIZE){
< 		cprintf("decrypt_var():Encrypted string is too long MAXSTRINGSIZE=%d Strlen=%d\n",
< 							NVRAM_MAX_STRINGSIZE,ctext_len);
< 	}
---
> // 	if (ctext_len > NVRAM_MAX_STRINGSIZE){
> // 		cprintf("decrypt_var():Encrypted string is too long MAXSTRINGSIZE=%d Strlen=%d\n",
> // 							NVRAM_MAX_STRINGSIZE,ctext_len);
> // 	}
15724,15725c15725,15726
< 	/* Cipher text must be more than 8 chars for this aes_unwrap() routine to work*/
< 	if (ctext_len < 8) return NULL;
---
> // 	/* Cipher text must be more than 8 chars for this aes_unwrap() routine to work*/
> // 	if (ctext_len < 8) return NULL;
15727c15728
< 	len=b64_decode(ctext,tmp,NVRAM_MAX_STRINGSIZE);
---
> // 	len=b64_decode(ctext,tmp,NVRAM_MAX_STRINGSIZE);
15729c15730
< 	if (!len) return NULL;
---
> // 	if (!len) return NULL;
15731,15732c15732,15733
< 	if (aes_unwrap(keylen,(unsigned char *)key,len,tmp,(unsigned char *)ptext))
< 		return NULL;
---
> // 	if (aes_unwrap(keylen,(unsigned char *)key,len,tmp,(unsigned char *)ptext))
> // 		return NULL;
15734c15735
< 	*ptext_len = len - 8;
---
> // 	*ptext_len = len - 8;
15736c15737
< 	end = strstr(ptext,varname);
---
> // 	end = strstr(ptext,varname);
15738,15741c15739,15742
< 	if (end)
< 		(*end)= '\0';
< 	else
< 		return NULL;
---
> // 	if (end)
> // 		(*end)= '\0';
> // 	else
> // 		return NULL;
15743,15744c15744,15745
< 	return ptext;
< }
---
> // 	return ptext;
> // }
15753,15812c15754,15813
< static char*
< encrypt_var(char *varname,char *ptext, int ptext_len, char *ctext, int *ctext_len,char *key, int keylen)
< {
< 	unsigned char tmp[NVRAM_MAX_STRINGSIZE];
< 	char *buf=NULL;
< 	int newlen;
< 	int varname_len;
< 
< 	assert(ptext);
< 	assert(ctext);
< 	assert(ctext_len);
< 	assert(key);
< 	if (keylen < 1 ) return NULL;
< 	if (ptext_len < 1) return NULL;
< 
< 	varname_len = strlen (varname);
< 
< 	 /* Include the NULL at the end */
< 	newlen = ptext_len + varname_len + 1;
< 	/* Align the incoming buffer to AES block length boundaries */
< 	if (newlen % AES_BLOCK_LEN)
< 		newlen = (1 + newlen /AES_BLOCK_LEN ) * AES_BLOCK_LEN;
< 
< 	/* Do a string length check. When the binary string is base-64 encoded
< 	   it becomes 30% larger as every 3 bytes are represented by 4 ascii
< 	   characters */
< 
< 	if ( (4*(1+(newlen+8)/3)) > NVRAM_MAX_STRINGSIZE )
< 	{
< 		cprintf("encrypt_var():The encrypted string is too long. MAXSTRINGSIZE=%d Strlen=%d\n",
< 				NVRAM_MAX_STRINGSIZE,(4*(1+(newlen+8)/3)));
< 		return NULL;
< 	}
< 
< 	buf  = malloc (newlen);
< 	if (!buf) return NULL;
< 	memset(buf,0,newlen);
< 	memcpy(buf,ptext,ptext_len);
< 	memcpy(buf + ptext_len,varname,varname_len);
< 
< 	if (aes_wrap(keylen,(unsigned char *)key,newlen,(unsigned char *)buf,
< 	             (unsigned char *)ctext)){
< 		if (buf) free(buf);
< 	 	return NULL;
< 	};
< 
< 	if (buf) free(buf);
< 
< 	buf = b64_encode((unsigned char *)ctext,newlen+8,tmp,NVRAM_MAX_STRINGSIZE-(ptext_len + 1));
< 
< 	if (buf){
< 		strncpy(ctext,buf,NVRAM_MAX_STRINGSIZE);
< 		*ctext_len = strlen(ctext) ;
< 		return ctext;
< 	} else {
< 		cprintf("encrypt_var():base-64 encode error\n");
< 		*ctext_len = 0;
< 		return NULL;
< 	}
< }
---
> // static char* NOTE
> // encrypt_var(char *varname,char *ptext, int ptext_len, char *ctext, int *ctext_len,char *key, int keylen)
> // {
> // 	unsigned char tmp[NVRAM_MAX_STRINGSIZE];
> // 	char *buf=NULL;
> // 	int newlen;
> // 	int varname_len;
> 
> // 	assert(ptext);
> // 	assert(ctext);
> // 	assert(ctext_len);
> // 	assert(key);
> // 	if (keylen < 1 ) return NULL;
> // 	if (ptext_len < 1) return NULL;
> 
> // 	varname_len = strlen (varname);
> 
> // 	 /* Include the NULL at the end */
> // 	newlen = ptext_len + varname_len + 1;
> // 	/* Align the incoming buffer to AES block length boundaries */
> // 	if (newlen % AES_BLOCK_LEN)
> // 		newlen = (1 + newlen /AES_BLOCK_LEN ) * AES_BLOCK_LEN;
> 
> // 	/* Do a string length check. When the binary string is base-64 encoded
> // 	   it becomes 30% larger as every 3 bytes are represented by 4 ascii
> // 	   characters */
> 
> // 	if ( (4*(1+(newlen+8)/3)) > NVRAM_MAX_STRINGSIZE )
> // 	{
> // 		cprintf("encrypt_var():The encrypted string is too long. MAXSTRINGSIZE=%d Strlen=%d\n",
> // 				NVRAM_MAX_STRINGSIZE,(4*(1+(newlen+8)/3)));
> // 		return NULL;
> // 	}
> 
> // 	buf  = malloc (newlen);
> // 	if (!buf) return NULL;
> // 	memset(buf,0,newlen);
> // 	memcpy(buf,ptext,ptext_len);
> // 	memcpy(buf + ptext_len,varname,varname_len);
> 
> // 	if (aes_wrap(keylen,(unsigned char *)key,newlen,(unsigned char *)buf,
> // 	             (unsigned char *)ctext)){
> // 		if (buf) free(buf);
> // 	 	return NULL;
> // 	};
> 
> // 	if (buf) free(buf);
> 
> // 	buf = b64_encode((unsigned char *)ctext,newlen+8,tmp,NVRAM_MAX_STRINGSIZE-(ptext_len + 1));
> 
> // 	if (buf){
> // 		strncpy(ctext,buf,NVRAM_MAX_STRINGSIZE);
> // 		*ctext_len = strlen(ctext) ;
> // 		return ctext;
> // 	} else {
> // 		cprintf("encrypt_var():base-64 encode error\n");
> // 		*ctext_len = 0;
> // 		return NULL;
> // 	}
> // }
19391,19392c19392,19393
< 	{ "nvramdl.cgi*", NULL, download_hdr, NULL, do_nvramdl_cgi, do_auth },
< 	{ "nvramul.cgi*", NULL, "text/html", do_nvramul_post,do_nvramul_cgi , do_auth },
---
> 	// { "nvramdl.cgi*", NULL, download_hdr, NULL, do_nvramdl_cgi, do_auth }, NOTE
> 	// { "nvramul.cgi*", NULL, "text/html", do_nvramul_post,do_nvramul_cgi , do_auth }, NOTE
